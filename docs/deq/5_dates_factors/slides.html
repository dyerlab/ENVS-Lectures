<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>The Title</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.11/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/middlebury.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/middlebury-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="deq-styles.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">

class: left, bottom
background-image: url("images/contour.png")
background-position: right
background-size: auto







# When `character` is Not String



### Mutation and the genesis of derived texual data



&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;img src="images/logo1.svg" width="400px"&gt;


---

# The Enigmatic Field Data CSV

For this, let's load in the data from the file in the project folder.


```r
library(tidyverse)
field_data &lt;- read_csv("Field_Data.csv")
```


 
and take a quick look at it.


```r
head( field_data )
```

```
## # A tibble: 6 × 7
##    Fdt_Id Fdt_Sta_Id  Fdt_Date_Time   Fdt_Depth Fdt_Salinity Fdt_Temp_Celcius
##     &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;               &lt;dbl&gt;        &lt;dbl&gt;            &lt;dbl&gt;
## 1 2966267 7ACHE055.97 8/12/2020 13:00      15           18.4             28.9
## 2 2965675 7ACHE040.39 8/11/2020 13:30       0.1         16.7             29.4
## 3 2965678 7ACHE040.39 8/11/2020 13:30       0.5         16.6             29.3
## 4 2965679 7ACHE040.39 8/11/2020 13:30       1           16.7             29.3
## 5 2965683 7ACHE040.39 8/11/2020 13:30       2           16.7             29.3
## 6 2965686 7ACHE040.39 8/11/2020 13:30       3           16.7             29.2
## # … with 1 more variable: Fdt_Do_Optical &lt;dbl&gt;
```






---
class: sectionTitle

# .green[Factors]

## .orange[7ACHE040.39] is not just a random string


---

# Factor Data Types

A `factor` is a kind of **categorical** data that is typically depicted as a sequence of `character` values. Consider the station column in the `Field Data` csv file.


```r
c( Records = length( field_data$Fdt_Sta_Id),
   Stations = length( unique( field_data$Fdt_Sta_Id ) ) )
```

```
##  Records Stations 
##      116       10
```

--



```r
unique( field_data$Fdt_Sta_Id )
```

```
##  [1] "7ACHE055.97" "7ACHE040.39" "7ACHE055.60" "7ACHE040.04" "7ACHE013.48"
##  [6] "7ACHE047.42" "7ACHE004.29" "7ACHE023.47" "7ACHE044.14" "7ACHE026.06"
```


---

# Specifying Factors - Mutation!!!!!

We are going to use `mutate()` to make changes to the data as we pipe it through our workflow.


```r
field_data %&gt;% mutate( Station = factor( Fdt_Sta_Id) ) %&gt;% names()
```

```
## [1] "Fdt_Id"           "Fdt_Sta_Id"       "Fdt_Date_Time"    "Fdt_Depth"       
## [5] "Fdt_Salinity"     "Fdt_Temp_Celcius" "Fdt_Do_Optical"   "Station"
```



---

# Factors are Fixed

Once we've specified the factors for data, we cannot *insert* new levels.


```r
field_data %&gt;% mutate( Station = factor( Fdt_Sta_Id) )  -&gt; df 
summary( df$Station )
```

```
## 7ACHE004.29 7ACHE013.48 7ACHE023.47 7ACHE026.06 7ACHE040.04 7ACHE040.39 
##           9           9          13          10          14          12 
## 7ACHE044.14 7ACHE047.42 7ACHE055.60 7ACHE055.97 
##          10           9          16          14
```

--

If we try to use a non-recognized level, it will not 'automagically' add a new level and instead give you missing data.


```r
df$Station[1] &lt;- "Rodney's Station ID"
summary( df$Station )
```

```
## 7ACHE004.29 7ACHE013.48 7ACHE023.47 7ACHE026.06 7ACHE040.04 7ACHE040.39 
##           9           9          13          10          14          12 
## 7ACHE044.14 7ACHE047.42 7ACHE055.60 7ACHE055.97        NA's 
##          10           9          16          13           1
```


---

# `Selecting` to Reorder &amp; Rename

In the previous example we used `mutate()` to add a column of derived data, which was appended to the right side of the data.frame.


```r
field_data %&gt;% mutate( Station = factor( Fdt_Sta_Id) )  %&gt;% names()
```

```
## [1] "Fdt_Id"           "Fdt_Sta_Id"       "Fdt_Date_Time"    "Fdt_Depth"       
## [5] "Fdt_Salinity"     "Fdt_Temp_Celcius" "Fdt_Do_Optical"   "Station"
```

--

If we'd like, we can use the `select()` function to reorder the columns (previously we used this to identify which columns to keep) as well as to rename them in transit.


```r
field_data %&gt;% 
  mutate( Station = factor( Fdt_Sta_Id) )  %&gt;% 
  select( ID = Fdt_Id, Station, Depth = Fdt_Depth ) %&gt;%
  names()
```

```
## [1] "ID"      "Station" "Depth"
```


---

# Anti Selecting

We can .red[invert] the selection to drop columns from the data frame.  


```r
field_data %&gt;%
  select( -Fdt_Id, -Fdt_Salinity, -Fdt_Do_Optical) %&gt;%
  head()
```

```
## # A tibble: 6 × 4
##   Fdt_Sta_Id  Fdt_Date_Time   Fdt_Depth Fdt_Temp_Celcius
##   &lt;chr&gt;       &lt;chr&gt;               &lt;dbl&gt;            &lt;dbl&gt;
## 1 7ACHE055.97 8/12/2020 13:00      15               28.9
## 2 7ACHE040.39 8/11/2020 13:30       0.1             29.4
## 3 7ACHE040.39 8/11/2020 13:30       0.5             29.3
## 4 7ACHE040.39 8/11/2020 13:30       1               29.3
## 5 7ACHE040.39 8/11/2020 13:30       2               29.3
## 6 7ACHE040.39 8/11/2020 13:30       3               29.2
```

---

# `everything` Else

When we have a lot of columns and want to select them without needing to type them, we can use `everything()`.  By default, the remaining columns are kept in the same order as before.


```r
field_data %&gt;%
  select( Station = Fdt_Sta_Id, 
          Depth = Fdt_Depth, 
          everything() ) %&gt;%
  head()
```

```
## # A tibble: 6 × 7
##   Station     Depth  Fdt_Id Fdt_Date_Time   Fdt_Salinity Fdt_Temp_Celcius
##   &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;                  &lt;dbl&gt;            &lt;dbl&gt;
## 1 7ACHE055.97  15   2966267 8/12/2020 13:00         18.4             28.9
## 2 7ACHE040.39   0.1 2965675 8/11/2020 13:30         16.7             29.4
## 3 7ACHE040.39   0.5 2965678 8/11/2020 13:30         16.6             29.3
## 4 7ACHE040.39   1   2965679 8/11/2020 13:30         16.7             29.3
## 5 7ACHE040.39   2   2965683 8/11/2020 13:30         16.7             29.3
## 6 7ACHE040.39   3   2965686 8/11/2020 13:30         16.7             29.2
## # … with 1 more variable: Fdt_Do_Optical &lt;dbl&gt;
```



---

# Ordered Factors

Some factors have an intrinsic *ordinality* to them. Let's consider the days of the week.  Here is a random sample of 50 weekdays.


```r
weekdays &lt;- c("Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday")
raw_days &lt;- sample( weekdays, size=50, replace=TRUE )
data &lt;- factor( raw_days )
summary(data)
```

```
##    Friday    Monday  Saturday    Sunday  Thursday   Tuesday Wednesday 
##        10         8         9         4         6         7         6
```

--

Because `weekdays` is just a `character` vector, they are tabulated in alphabetic order—which is rather unfortunate because I like .green[a little more space] between Friday &amp; Monday!

---

# Creating Ordered Factors

If there is an intrinsic order we need to tell `factor()` that these data are ordinal and if the arrangment is not alphanumeric we **must** specify the arrangement of the levels.


```r
data &lt;- factor( raw_days, 
                ordered = TRUE,
                levels = weekdays )
summary( data )
```

```
##    Monday   Tuesday Wednesday  Thursday    Friday  Saturday    Sunday 
##         8         7         6         6        10         9         4
```




---

# Station Ordinality


```r
sort(unique( field_data$Fdt_Sta_Id ))
```

```
##  [1] "7ACHE004.29" "7ACHE013.48" "7ACHE023.47" "7ACHE026.06" "7ACHE040.04"
##  [6] "7ACHE040.39" "7ACHE044.14" "7ACHE047.42" "7ACHE055.60" "7ACHE055.97"
```

As I understand it, the .red[7ACHE] means Chesapeake Bay (of course) and the remaining values in the station name (e.g., .red[004.29]) represent the distance in miles along the main channel from the mouth.  In this case, the foresight of the data providers allow you to order the stations by river location as they sort alphanumerially.

---

# `arrange` works on ordered factors too


```r
field_data %&gt;%
  mutate( Station = factor( Fdt_Sta_Id, ordered=TRUE) ) %&gt;% 
  select( Station , Depth = Fdt_Depth ) %&gt;%
  arrange( Station ) 
```

```
## # A tibble: 116 × 2
##    Station     Depth
##    &lt;ord&gt;       &lt;dbl&gt;
##  1 7ACHE004.29   1  
##  2 7ACHE004.29   2  
##  3 7ACHE004.29   3  
##  4 7ACHE004.29   4  
##  5 7ACHE004.29   5  
##  6 7ACHE004.29   0.1
##  7 7ACHE004.29   0.5
##  8 7ACHE004.29   6  
##  9 7ACHE004.29   7  
## 10 7ACHE013.48   0.1
## # … with 106 more rows
```


---

# Missing Factor Levels

There are times when we have a subset of potential levels for a factor (here `sample_n()` randomly selects as many rows as you indicate in `size=`).  


```r
field_data %&gt;% 
  mutate( Station = factor( Fdt_Sta_Id, ordered=TRUE) ) %&gt;% 
  sample_n(size = 8) %&gt;%
  select( Station ) %&gt;%
  table()
```

```
## .
## 7ACHE004.29 7ACHE013.48 7ACHE023.47 7ACHE026.06 7ACHE040.04 7ACHE040.39 
##           1           0           2           1           0           0 
## 7ACHE044.14 7ACHE047.42 7ACHE055.60 7ACHE055.97 
##           0           1           1           2
```

--

But there are times when having those missing values in the data is not desirable (e.g., plotting values or making tables).  

---

# Dropping levels

We can disregard the missing `levels` for a factor by passing it through 


```r
field_data %&gt;% 
  mutate( Station = factor( Fdt_Sta_Id, ordered=TRUE) ) %&gt;% 
  sample_n(size = 8) %&gt;%
  select( Station ) %&gt;%
  droplevels() %&gt;%
  table()
```

```
## .
## 7ACHE004.29 7ACHE023.47 7ACHE026.06 7ACHE040.04 7ACHE040.39 7ACHE047.42 
##           1           1           1           1           1           1 
## 7ACHE055.60 
##           2
```



---

# More Information

There is a much deeper body of factor manipulation you can do using the `forcats` library, which is included as part of `tidyverse` and is loaded in already. Take a look at this cheatsheet to see some of the included functions.

&amp;nbsp;

## .center[ [ Forcats Cheatsheet](http://www.flutterbys.com.au/stats/downloads/slides/figure/factors.pdf)]







---
class: sectionTitle

# .blue[Dates 📅]

## When "8/18/2020" != August 18, 2020 

---
# Date Objects

When we read a date and/or time object, it is typically given in a textual form:

- February 14, 2021
- Tomorrow @ noon.
- Next Wednesday morning.

But in `R` we need to be able to specify these these textual representations (which mean a lot to us when we read them) into objects that we can perform actual operations on.


---

# Date &amp; Time Challenges

We must consider the following when attempting to conduct *operations* on date and time units.

1. Many different calendars.  

2. Leap days, years, seconds.

3. Time Zones (looking at you Arizona).

4. Non-consistent base units (60 seconds, 60 minutes, 24 hours, 7 days, 28/29/30/31 days, 12 months, 100 years, 10 centuries)



---

# Date from Field Data

Our favorite data set has a column of date/time information.


```r
head( field_data$Fdt_Date_Time )
```

```
## [1] "8/12/2020 13:00" "8/11/2020 13:30" "8/11/2020 13:30" "8/11/2020 13:30"
## [5] "8/11/2020 13:30" "8/11/2020 13:30"
```

that is actually treated just as a `character` column of data.


```r
class( field_data$Fdt_Date_Time )
```

```
## [1] "character"
```

---

# Date Data Types

A character data type representing dates and times is ok for us to look at but it is not helpful for doing any kind of operations on.  

`R` defines a specific data type that represents dates and time.


```r
today &lt;- as.Date( "2022-03-07")
today
```

```
## [1] "2022-03-07"
```

```r
class(today)
```

```
## [1] "Date"
```


---

# Date Operations

Now, this is extremely powerful because we can now do operations on date objects such as:


```r
dyer_birth &lt;- as.Date("1969-10-14")
today - dyer_birth
```

```
## Time difference of 19137 days
```
--

```r
weekdays( today )
```

```
## [1] "Monday"
```

```r
weekdays( dyer_birth  )
```

```
## [1] "Tuesday"
```
--

```r
julian(today)
```

```
## [1] 19058
## attr(,"origin")
## [1] "1970-01-01"
```



---

# The Unix Epoch - Time Zero!

.red[.center[.large[00:00:00 January 1, 1970]]]


Time on computers is kept as the number of seconds since the *epoch*.  It is only .blueinline[displayed] in the Gregorian, Julian, Chinese, Jewish, and other calendars.




```r
Sys.time()
```

```
## [1] "2022-03-06 16:52:13 EST"
```

--


```r
unclass( Sys.time() )
```

```
## [1] 1646603533
```


---

# Making Time 🕤

To convert something like 8/12/2020 13:00 from `character` to a `time` object, we need to *specify* the layout of the elements within the string so the functions know what to operate on.


.pull-left[

- Month as 1 or 2 digits  
- Day as 1 or 2 digits  
- Year as 4 digits
- / separating date objects  
- a space to separate date from time  
- hour (not 24-hour though)  
- minutes in 2 digits
- : separating time objects  


.gray[
Other Common Features:
- seconds in 2 digits  
- timezone  
]

]

--

.pull-right[
The `lubridate` library


```r
library( lubridate )
x &lt;- field_data$Fdt_Date_Time[1]
format &lt;- ""
```


]


---

# Custom Configurations


```r
field_data$Fdt_Date_Time[1]
```

```
## [1] "8/12/2020 13:00"
```

So this format is 

```r
format &lt;- "%m/%d/%Y %H:%M"
```

--

Which we pass to the function to parse it from `character` to `date` object:


```r
parse_date_time( field_data$Fdt_Date_Time[1], orders=format )
```

```
## [1] "2020-08-12 13:00:00 UTC"
```
--

```r
parse_date_time( field_data$Fdt_Date_Time[1], orders=format, tz="EST" )
```

```
## [1] "2020-08-12 13:00:00 EST"
```

---

# Applying to Data Frame

Let's take the current `Fdt_Date_Time` column and turn it into a real `Date` object.


```r
field_data %&gt;%
  mutate( Date = parse_date_time( Fdt_Date_Time, 
                                  orders=format, 
                                  tz="EST") ) -&gt; field_data
  
summary( field_data$Date )
```

```
##                  Min.               1st Qu.                Median 
## "2020-08-10 08:00:00" "2020-08-11 08:30:00" "2020-08-11 15:30:00" 
##                  Mean               3rd Qu.                  Max. 
## "2020-08-13 00:44:36" "2020-08-12 13:00:00" "2020-08-18 12:00:00"
```


---

# Derivatives of Date Objects

Date objects have access to a wide array of derivative type including: `day()`, `month()`, `year()`, `weekday()`, `julian()`, etc.  Here we can quickly find the mean temperature by day and weekday of the month.


```r
field_data %&gt;%
  mutate( Day = day(Date),
          Weekday = weekdays(Date)) %&gt;%
  mutate( Weekday = factor(Weekday) ) %&gt;%
  group_by( Day, Weekday ) %&gt;%
  summarize( Temperature = mean( Fdt_Temp_Celcius))
```

```
## # A tibble: 4 × 3
## # Groups:   Day [4]
##     Day Weekday   Temperature
##   &lt;int&gt; &lt;fct&gt;           &lt;dbl&gt;
## 1    10 Monday           27.3
## 2    11 Tuesday          28.7
## 3    12 Wednesday        28.9
## 4    18 Tuesday          26.7
```


---

# Tabulating Categorical Data


```r
field_data %&gt;%
  mutate( Weekday = weekdays(Date) ) %&gt;%
  select( Weekday ) %&gt;%
  table()
```

```
## .
##    Monday   Tuesday Wednesday 
##        18        68        30
```




---

# 15 Minute Activity - Format the Field Data

Open a new `R` file and save as `dates_factors.R` and save it in the Project folder.  In that file do the following steps to load in and format the data set so that at the end of it your data are ready for analyses.

1. Load in the libraries you need (e.g., `tidyverse` and `lubridate`).  

2. Load in the `Field_Data.csv` file.

3. Format the `Fdt_Sta_Id` as a `factor`.

4. Format the `Fdt_Date_Time` as a `date` object.

5. Rename the variables to sane values...

6. **BONUS**: Tabulate the number of samples for each station by weekday.  Why are the results like this?












---

class: middle
background-image: url("images/contour.png")
background-position: right
background-size: auto

.center[


![## Any Questions](https://media.giphy.com/media/03g9zDwQ95MyB08oc0/giphy.gif)

]




    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"ratio": "16:9",
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
