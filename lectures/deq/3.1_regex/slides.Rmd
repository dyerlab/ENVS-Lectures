---
title: "The Title"
subtitle: "The Subtitle"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: [deq-styles.css, middlebury, middlebury-fonts]
    seal: false
    nature:
      titleSlideClass: ["center","middle"]
      highlightStyle: github
      highlightLines: true
      ratio: '16:9'
      countIncrementalSlides: false
---

class: left, bottom
background-image: url("images/contour.png")
background-position: right
background-size: auto


# Regular Expressions



### What the what?  And where?


<p>&nbsp;</p>

<p>&nbsp;</p>

<img src="images/logo1.svg" width="400px">




---

class: sectionTitle

# Regular Expressions


## Searching with Wildcards



---

# Regular Expressions

This could be a whole .red[frickin] class in itself.  I'm going to keep it very simple here so you have enough knowledge to get in trouble.

> Regular Expression is a sequence of characters that defines a search pattern.  These are **very terse** descriptions of textual patterns.


--

```{r}
library( tidyverse )
names <- c("Kingsley","Plimpton","Ted Knight", "Zissou")
names
```


---

# Visualizing Matches for Learning

The function `str_view()` is designed to **only** show you where matches are made to help you learn regex, we **never** actually use it in practice.  

Visualizing matches for the letter *i* 

```{r warning=FALSE, message=FALSE}
str_view( names, "i")
```


---

# Positional Matches

Matching based upon position can be used with the addition of a special character.  Here the `$` indicates that it is at the .red[very end] of the string.

```{r}
str_view( names, "n$")
```

---

# Positional Matches

And the `^` character marks .red[the beginning] of a string.

```{r}
str_view( names, "^K")
```

Notice how it *does not* match the 'K' in Knight.

---

# Character Classes

We can also match kinds of characters such as a number, whose shortcut is `\d`.  However, to have it match as a character class, we need to be careful of the `\` character.  

There are some special characters such as `\t` (tab), `\r` (carrage return), and `\n` newline that are shorthand ways of indicating these non-printing entities on your keyboard.  As such, a `\` is treated .red[speically] to indicate that the next glyph will indicate a special character.  But if we try to use it like this:

```{r error = FALSE, eval=FALSE}
str_view( myClasses, "\d" )
```
.red[```#  Error: '\d' is an unrecognized escape in character string starting ""\d"```]


Which is an error.  

---

# Character Classes

This is because the digit indication for a regular expression includes a `\` not as a "escape character" but as part of it directly!  So, we need to escape it as well (confused yet?  stick with me, it will get better).

So to match the first generic number in each of the entries, we would use

```{r}
myClasses <- str_c("ENVS", c(521, 543, 601, 602), sep="-" )
str_view( myClasses, "\\d" )
```

---

# Number of Character Classes

You can match more than one of the characters.

```{r}
str_view(myClasses, "\\d\\d")
```

---

# Matching "other" 

The `"."` character indicates another glyph (of any type) 

```{r}
str_view( myClasses, "\\d.+")
```


---

# Finding Words

We can also match on 'words' or 'whitespace'.

```{r}
text <- "It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of light, it was the season of darkness, it was the spring of hope, it was the winter of despair."
```

This grabs the first word (grabbed by the `\\w` that is immediately followed by a comma.)
```{r}
str_view( text, "\\w\\,")
```


```{r}
str_view( text, "\\w\\s(belief)")
```

---

# Numbers of matches

We can match things by the number of occurrences.  Consider the following searches for the lowercase letter `o`.

- `o*` Finding zero or more times
- `o+` Finding one or more times.
- `o?` Either 0 or 1 times

```{r}
str_view( text, "o+")
```


---

# Finding `N` items.

```{r}
year_1888 <- "MDCCCLXXXVIII"
str_view( year_1888, "X{3}")
```



---

# Variable Numbers of Matches

How about finding where the string contains either 2 consecutive lowercase 'o' values? 

```{r}
str_view( text, "o{2,3}" )
```


---

# A Greedy Algorithm

Given the opportunity, it will identify the location of the longest match.


```{r}
str_view( year_1888, "C{1,4}")
```



---

# Locating the Position of Elements

```{r}
str_locate( text, "epoch")
```

---

# Locating Every Instance of an Element

Finding *all* the start and ending positions for a particular sequence.

```{r}
str_locate_all( text, "it was the")
```

--

From this `str_sub()` can be used to extract elements within (or between) identified occurances.  Here is an example of the 

```{r}
str_sub( text, 80, 110)
```





---

# Extracting Elements

We can do a similar thing to pull out the components.

```{r}
str_extract( text, "epoch")
str_extract_all( text, "it was the")
```


---

# Some More Options

It will be more exciting if we could use `str_extract()` in a way that allows us to capture more than just **exactly** what we asked for it to find.  


Item | Definition
-----|-----------------------------  
`^`  | The start of a string match  
`$`  | The end of a string match  
`(`  | The start of a capture group  
`)`  | The end of a capture group  

---

# More Exciting, no?

So, if we want to find the .red[word] that occurs right before the comma in the text, we create a *capture group* representing one or more word elements (`\w`) followed by a comma. 


```{r}
str_extract_all( text, "(\\w*)," )
```

--

Simplifying the result a bit.

```{r}
str_extract_all( text, "(\\w*),", simplify = TRUE)
```



---

# Matching Sequences

We can define sequences by enclosing them into parentheses.  So to search for all entries that have a `6` and a `0` right next to each other, we could.

```{r}
str_view( myClasses, "(60)")
str_view( myClasses, "ENVS-(60)")
```

---

# Optional Characters - This OR That

This may be convenient when there are a few different kinds of spellings.

```{r}
str_view( c("gray", "grey"), "r(a|e)y")
```


---

# Numbers of Matches in a Sequence

Let's look at a larger set of words and do some actual detection where we are not intersted in showing the results (using `str_view()` but working with the answers themselves).  

Let's use the built-in `words` data, which has ... words

```{r}
head( words )
tail( words )
length( words )
```


---

# Counts of Items

Simply finding something may be good for determining if something exists.  However, we may want to count how many occurrences of something are in the text string.  

Here is an example where we use `str_detect()` to return `TRUE/FALSE` for matching the pattern and then count how many `TRUE` results there are.

```{r}
startingWithR <- str_detect( words, "^r")
sum( startingWithR )
```

--

Could combine the two (looking at words ending in `r` this time) as: 

```{r}
sum( str_detect( words, "r$")    )
```

---

# Negation (the opposite of)

Fraction of words starting with a vowel in vowel

```{r}
mean( str_detect( words, "^[aeiou]")  )
```

--

vs. the fraction that **DO NOT** start with a vowel

```{r}
mean( !str_detect( words, "^[aeiou]")  )
```

(n.b., these two numbers *better* sum to 1.0!)


---

# Selecting Elements

The function `str_detect()` is commonly used to find elements in an array that match an expression and then use this result as an index on the sequences to pull them out.

```{r}
words[ str_detect( words, "r$")   ]
```




---


```{r}
str_detect( words, "r$")
```


---

# Splitting Strings

It is common for us to try to split strings into sections.  It could be for files we get from a computer (relative to the starting:

```{r}
geoTIFFS <- list.files(path = "/Users/rodney/Documents/github/classes/ENVS-Lectures", recursive = TRUE, pattern = "tif" )
geoTIFFS
```

---

# Files & File Paths

```{r}
file <- geoTIFFS[13]
file
```

--

It is so common to deal with file names (and so problematic because of the folder specifier is `\` but one platform incorrectly uses `/`)


```{r}
basename(file)
dirname( file )
```

---

.pull-left[

# `str_split()` Components

When we split a string, it is returned as a `list` of objects.

**Lists**

- Lists are a kind of container

- Allow different kinds of data 

- Indexed by **either** number or character key

- Uses 2 [[ and 2 ]] for indexes.
]

.pull-right[
```{r}
file_parts <- str_split( geoTIFFS, pattern="/")
class( file_parts )
length( file_parts )
file_parts[1:5]
file_parts[[1]][2]
```
]



---

# From File Contents

Or from the contents of an individual data file.  This file can be local (as in `~/data/alt_22.tif` in the previous slide) or on a remote computer somewhere.  Here is a data file that I use in teaching and is located in my github repository.  It describes the 100 beer styles recognized for competition by the international Beer Judge Certification Program (BJCP and yes there is such an organization).

```{r}
beerStyles <- readLines( "https://github.com/dyerlab/ENVS-Lectures/raw/master/data/Beer_Styles.csv")
beerStyles[1:10]
```


---

```{r}
read_csv("https://github.com/dyerlab/ENVS-Lectures/raw/master/data/Beer_Styles.csv")
```


.footnote[ `read_csv()` is in the `readr` library which is part of the `tidyverse.]


























---

class: middle
background-image: url("images/contour.png")
background-position: right
background-size: auto

.center[

# Questions?


![Peter Sellers](images/peter_sellers.gif)
]

<p>&nbsp;</p>

.bottom[ If you have any questions for about the content presented herein, please feel free to [submit them to me](https://docs.google.com/forms/d/e/1FAIpQLScrAGM5Zl8vZTPqV8DVSnSrf_5enypyp0717jG4PZiTlVHDjQ/viewform?usp=sf_link) and I'll get back to you as soon as possible.]


