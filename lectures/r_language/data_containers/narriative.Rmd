---
title: "Data Containers"
output: 
  html_notebook:
      css: "envs543-styles.css"
---

All of the collection types below can be applied to any of the data types discussed [previously](https://dyerlab.github.io/ENVS-Lectures/data_types/narriative.nb.html).


## Vectors of Values

It is rather rare that we work with a single entity for any data type.   The main syntax in `R` used to make a collection of objects is to enclose them into the `c()` function (*c* for *c*ombine and since we use it so often, making it as short as possibleâ€”anything we can do to type less is good for reducing the number of errors in our code).  

Here is how we can get a vector of `numeric` values.

```{r}
x <- c(1,2,3,4,5,6,7)
x
```

The variable `x` contains a number of numeric types and is a single object.

```{r}
length( x )
```



### Sequences

It would really suck if we had to type in all the elements into every array we want.  Say we want a vector of 100 numbers, it would be really likely if we had to type all the numbers `1, 2, 3, ... , 99, 100` (and quite boring `r emo::ji("zzz")`).  The main way we will get data into `R` is by loading it from files or databases, which we will get to later, but for now let's look at how we can specifically create sequences of values with a little bit of code.

The first is the colon operator.  The syntax is `X:Y` which will produce the values from `X` to `Y` (inclusive on both ends).  In `R` we use it like this:

```{r}
y <- 3:8 
y
```

This is just a shortcut for the more general `seq()` function (*seq* is short for *sequence*).  This function takes a value to start at and one to end with (inclusive just like above).

```{r}
y <- seq(3,8)
y
```

These are the *required* arguments.  By default, the `seq()` function counts by $1.0$ (either up or down, depending upon the magnitude of the first and second argument).

```{r}
seq(8,3)
```

If we want it to count by some other interval, we can tell it by passing the *optional argument* `by=`.

```{r}
y <- seq(3,8,by=0.25)
y
```



### Indexing

Even though these objects are solitary, they have several elements.  For example, the object `y` above has `r length(y)` entities in it.  To get to these individual entities within the `y` we use a square bracket notation to indicate that we want to get an item *within* the variable and must indicate which element (or elements) we are interested in getting.  The numeric indices within the brackets are 1-based (e.g., the first element is 1, the second is 2, etc.).  So the code

```{r}
y[4]
```

returns the 4$^{th}$ element in the vector.  This notation can be used to *get* as well as *set* values within the vector.

```{r}
y[2] <- 42
y
```

### Slices

In addition to getting a single entity from a vector, we can also grab a sequence of values by using a set of indices within the square brackets.  For example, if I wanted the first five entries of `y` I could ask for it as:

```{r}
y[1:5]
```









